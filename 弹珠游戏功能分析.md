# 弹珠游戏功能分析

## 1. 整体架构设计

### 1.1 技术栈
- **开发语言**：C语言
- **图形库**：ncurses（终端图形界面库）
- **线程库**：pthread（多线程支持）
- **编译工具**：GCC

### 1.2 整体架构
本游戏采用**多线程架构**，分为以下两个主要线程：

| 线程名称 | 主要职责 | 实现文件 |
|---------|---------|---------|
| 主线程  | 处理用户输入、初始化游戏环境、管理游戏生命周期 | main函数 |
| 绘图线程 | 负责游戏画面绘制、球的运动逻辑、碰撞检测 | paint_thread函数 |

### 1.3 核心设计模式
- **共享数据模型**：主线程与绘图线程通过全局变量共享游戏状态
- **互斥锁保护**：使用pthread_mutex_t互斥锁保护共享变量的并发访问
- **非阻塞IO**：使用ncurses的nodelay机制实现非阻塞输入，提高响应速度

## 2. 核心业务逻辑流程

### 2.1 游戏初始化流程
1. 初始化ncurses库，设置终端模式
2. 初始化随机数种子
3. 初始化互斥锁
4. 调用new_game()函数设置游戏初始状态
5. 创建绘图线程

### 2.2 游戏主循环流程
```
主线程：
┌───────────────────────────────────────────────────────────┐
│ while (true) {                                           │
│   1. 获取用户输入（非阻塞）                              │
│   2. 处理输入：                                          │
│      - 'Q'/'q'：退出游戏                                │
│      - 方向键左右：移动挡板                              │
│      - 'N'/'n'：重新开始游戏                            │
│   3. 短暂休眠（50ms），降低CPU占用                      │
│ }                                                        │
└───────────────────────────────────────────────────────────┘

绘图线程：
┌───────────────────────────────────────────────────────────┐
│ while (true) {                                           │
│   1. 加锁保护共享变量                                    │
│   2. 如果游戏未结束：                                    │
│      - 清除屏幕                                          │
│      - 绘制游戏边界                                      │
│      - 绘制球和挡板                                      │
│      - 更新球的位置                                      │
│      - 检测碰撞并处理                                    │
│      - 检查游戏是否结束                                  │
│   3. 解锁互斥锁                                          │
│   4. 休眠100ms，控制游戏速度                             │
│ }                                                        │
└───────────────────────────────────────────────────────────┘
```

### 2.3 碰撞检测流程
1. **碰撞左右边界**：球的x坐标超出游戏区域左右边界时，x方向速度反向
2. **碰撞上边界**：球的y坐标小于0时，y方向速度反向
3. **碰撞挡板**：球的y坐标等于挡板上方，且x坐标在挡板范围内时，y方向速度反向
4. **球落地**：球的y坐标大于等于屏幕底部时，游戏结束

## 3. 功能模块分析

### 3.1 游戏初始化模块

#### 3.1.1 功能描述
负责初始化游戏的各项参数，包括球的位置、速度、方向，挡板的位置、长度，以及游戏状态。

#### 3.1.2 实现方法
- **函数名**：`new_game()`
- **参数**：无
- **返回值**：无
- **核心逻辑**：
  ```c
  void new_game() {
      // 计算游戏区域边界
      // 初始化球的位置、速度、方向
      // 初始化挡板位置和长度
      // 设置游戏状态为未结束
  }
  ```

### 3.2 绘图与动画模块

#### 3.2.1 功能描述
负责游戏画面的绘制、球的运动更新和碰撞检测。

#### 3.2.2 实现方法
- **线程函数**：`paint_thread(void* arg)`
- **核心逻辑**：
  1. 清除屏幕
  2. 绘制游戏边界（左右垂直墙）
  3. 绘制球和挡板
  4. 更新球的坐标
  5. 检测碰撞并处理
  6. 检查游戏是否结束
  7. 刷新屏幕显示

### 3.3 输入处理模块

#### 3.3.1 功能描述
处理用户的键盘输入，包括移动挡板、重新开始游戏和退出游戏。

#### 3.3.2 实现方法
- **核心逻辑**：
  ```c
  input = getch();  // 非阻塞获取输入
  switch (input) {
      case 'q' || 'Q':  // 退出游戏
          break;
      case KEY_LEFT:     // 挡板左移
          break;
      case KEY_RIGHT:    // 挡板右移
          break;
      case 'n' || 'N':   // 重新开始游戏
          break;
  }
  ```

### 3.4 碰撞检测模块

#### 3.4.1 功能描述
检测球与游戏边界、挡板和地面的碰撞，并根据碰撞结果更新游戏状态。

#### 3.4.2 实现方法
- **碰撞左右边界**：
  ```c
  if (ballx >= right_bound || ballx <= left_bound) {
      dx = -dx;  // x方向反向
      beep();    // 发出提示音
  }
  ```

- **碰撞上边界**：
  ```c
  if (bally < 0) {
      dy = -dy;  // y方向反向
      beep();    // 发出提示音
  }
  ```

- **碰撞挡板**：
  ```c
  if (bally == bary - 1 && ballx >= barx && ballx < barx + barlength) {
      dy = -dy;  // y方向反向
      beep();    // 发出提示音
  }
  ```

- **球落地（游戏结束）**：
  ```c
  if (bally >= LINES - 1) {
      game_over = true;
      // 显示游戏结束信息
  }
  ```

### 3.5 多线程同步模块

#### 3.5.1 功能描述
确保主线程和绘图线程之间的共享变量访问安全，防止数据竞争。

#### 3.5.2 实现方法
- **互斥锁**：使用`pthread_mutex_t mutex`保护共享变量
- **加锁时机**：
  - 访问或修改共享变量前加锁
  - 操作完成后立即解锁
- **共享变量列表**：
  ```c
  int ballx, bally, dx, dy;  // 球的位置和速度
  int barx, bary, barlength;  // 挡板位置和长度
  char ball, *bar;            // 球和挡板的显示字符
  bool game_over;             // 游戏状态
  ```

## 4. 代码结构分析

### 4.1 全局变量
| 变量名 | 类型 | 作用 |
|-------|------|------|
| ballx, bally | int | 球的当前坐标 |
| dx, dy | int | 球的x、y方向速度（1或-1） |
| barx, bary | int | 挡板的左上角坐标 |
| barlength | int | 挡板长度 |
| ball | char | 球的显示字符 |
| bar | char* | 挡板的显示字符串 |
| game_over | bool | 游戏状态（true：结束，false：进行中） |
| mutex | pthread_mutex_t | 互斥锁 |

### 4.2 核心函数

| 函数名 | 返回类型 | 参数 | 作用 |
|-------|---------|------|------|
| new_game | void | 无 | 初始化游戏状态 |
| paint_thread | void* | void* arg | 绘图线程函数 |
| main | int | 无 | 主函数，游戏入口 |

## 5. 功能实现细节

### 5.1 游戏区域设计
- 游戏区域宽度为屏幕宽度的一半
- 左右边界自动计算，居中显示
- 垂直边界用'|'字符绘制

### 5.2 球的运动逻辑
- 初始位置：屏幕中心
- 初始方向：随机（x和y方向均为1或-1）
- 移动速度：每100ms更新一次位置
- 碰撞反弹：碰到边界或挡板时，相应方向速度反向

### 5.3 挡板控制
- 初始位置：屏幕底部中央
- 初始长度：10个字符
- 移动方式：使用方向键左右移动，每次移动2个字符位置
- 移动限制：不能超出游戏区域边界

### 5.4 游戏状态管理
- **运行中**：显示游戏画面，球持续运动
- **结束**：显示游戏结束信息，包括：
  - "Game Over!"
  - "Press 'N' to restart"
  - "Press 'Q' to quit"

### 5.5 音效设计
- 使用ncurses的`beep()`函数在碰撞时发出提示音

## 6. 性能优化设计

### 6.1 线程休眠机制
- 绘图线程：每100ms休眠一次，控制游戏速度
- 主线程：每50ms休眠一次，降低CPU占用

### 6.2 非阻塞输入
- 使用`nodelay(stdscr, TRUE)`启用非阻塞输入
- 提高游戏响应速度，避免输入等待导致的卡顿

### 6.3 互斥锁优化
- 仅在访问共享变量时加锁，减少锁竞争
- 锁的持有时间尽可能短，提高并发性能

## 7. 代码优化建议

### 7.1 代码结构优化
1. **封装共享变量**：将共享变量封装为结构体，提高代码可维护性
2. **分离碰撞检测**：将碰撞检测逻辑独立为函数，提高代码模块化程度
3. **添加配置常量**：将游戏参数（如挡板长度、球速等）定义为常量，方便调整

### 7.2 功能扩展建议
1. **添加计分系统**：记录玩家得分，增强游戏可玩性
2. **增加难度等级**：随游戏进行，逐渐提高球的速度或缩短挡板长度
3. **添加关卡设计**：不同关卡有不同的游戏区域或障碍物
4. **支持自定义键位**：允许玩家自定义控制键位
5. **添加音效选项**：允许开关音效或选择不同音效

### 7.3 性能优化建议
1. **减少屏幕刷新频率**：仅在必要时刷新屏幕，而非每次循环都刷新
2. **使用双缓冲**：减少屏幕闪烁，提高视觉效果
3. **优化碰撞检测算法**：减少不必要的碰撞检测计算

## 8. 编译与运行说明

### 8.1 编译命令
```bash
gcc -o ball_game ball_game_thread.c -lncurses -lpthread
```

### 8.2 运行命令
```bash
./ball_game
```

### 8.3 控制说明
| 按键 | 功能 |
|------|------|
| 方向键左 | 挡板左移 |
| 方向键右 | 挡板右移 |
| N/n | 重新开始游戏 |
| Q/q | 退出游戏 |

## 9. 代码变更记录

| 日期 | 变更内容 | 变更人 | 备注 |
|------|----------|--------|------|
| 2025-12-08 | 初始代码分析 | 系统 | - |

## 10. 新增功能记录

### 10.1 新增功能记录_序号001

#### 功能名称
双缓冲技术实现

#### 功能描述
实现双缓冲技术，减少游戏画面刷新时产生的闪烁现象，提高视觉效果和游戏流畅度。双缓冲通过将所有绘图操作先绘制到后台缓冲区，然后一次性刷新到前台屏幕，避免了绘制过程中出现的撕裂和闪烁问题。

#### 业务逻辑设计思路
1. **后台缓冲区创建**：在游戏初始化时创建一个与屏幕大小相同的后台窗口
2. **绘图操作重定向**：将所有绘图操作从前台屏幕重定向到后台窗口
3. **批量刷新机制**：绘图完成后，将后台窗口内容一次性刷新到前台屏幕
4. **资源管理**：在游戏结束时正确销毁后台窗口，释放资源

#### 技术实现方案及方法

- **修改的文件**：`ball_game_thread.c`

- **新增的变量**：
  ```c
  WINDOW *bg_win;  // 后台窗口（双缓冲用）
  ```

- **修改的函数**：
  1. **main函数**：
     - 添加后台窗口创建代码
     - 添加后台窗口销毁代码
  
  2. **paint_thread函数**：
     - 将所有绘图操作从stdscr切换到bg_win
     - 添加双缓冲刷新机制

- **核心实现代码**：
  ```c
  // 1. 创建后台窗口
  bg_win = newwin(LINES, COLS, 0, 0);
  
  // 2. 使用后台窗口绘图
  wclear(bg_win);
  mvwaddch(bg_win, i, left_bound, '|');
  mvwaddch(bg_win, bally, ballx, ball);
  mvwaddstr(bg_win, bary, barx, bar);
  
  // 3. 双缓冲刷新
  wrefresh(bg_win);
  
  // 4. 销毁后台窗口
  if (bg_win != NULL) {
      delwin(bg_win);
      bg_win = NULL;
  }
  ```

- **与现有代码的集成方式**：
  - 保持原有游戏逻辑不变
  - 仅修改绘图相关的函数调用
  - 不影响游戏的核心业务逻辑

#### 测试方法

1. **编译测试**：
   ```bash
   gcc -o ball_game ball_game_thread.c -lncurses -lpthread
   ```
   预期结果：编译成功，无报错

2. **运行测试**：
   ```bash
   ./ball_game
   ```
   预期结果：游戏正常运行，画面无闪烁

3. **功能测试**：
   - 检查球的运动是否流畅
   - 检查挡板移动是否无延迟
   - 检查游戏结束画面是否正常显示
   - 检查屏幕是否有闪烁现象

#### 变更日期
2025-12-08

### 10.2 新增功能记录_序号002

#### 功能名称
弹珠发射与碰撞优化

#### 功能描述
优化弹珠的发射逻辑和碰撞反弹效果，解决弹珠直线来回弹动的问题。实现弹珠随挡板移动、空格键发射，以及根据碰撞位置动态调整反弹方向，提高游戏的随机性和可玩性。

#### 业务逻辑设计思路
1. **弹珠初始状态**：游戏开始时，弹珠固定在挡板正中央上方一格
2. **弹珠随挡板移动**：未发射前，弹珠跟随挡板一起移动
3. **空格键发射**：按下空格键后，弹珠开始向上运动
4. **动态碰撞反弹**：根据碰撞位置调整x方向速度，实现真实的反弹效果

#### 技术实现方案及方法

- **修改的文件**：`ball_game_thread.c`

- **新增的变量**：
  ```c
  bool ball_launched;  // 标记弹珠是否已发射
  ```

- **修改的函数**：
  1. **new_game函数**：
     - 初始化弹珠位置固定在挡板正上方
     - 设置弹珠初始发射状态为false
     - 初始化随机x方向速度
  
  2. **paint_thread函数**：
     - 添加弹珠随挡板移动的逻辑
     - 优化挡板碰撞反弹效果，根据碰撞位置调整dx方向
  
  3. **main函数**：
     - 添加空格键处理逻辑，实现弹珠发射

- **核心实现代码**：
  ```c
  // 弹珠随挡板移动逻辑
  if (ball_launched) {
      ballx += dx;
      bally += dy;
  } else {
      ballx = barx + barlength / 2;
      bally = bary - 1;
  }
  
  // 挡板碰撞优化
  if (bally == bary - 1 && ballx >= barx && ballx < barx + barlength) {
      dy = -dy;
      int bar_center = barx + barlength / 2;
      if (ballx < bar_center - 2) {
          dx = -1;  // 碰撞左侧，向左反弹
      } else if (ballx > bar_center + 2) {
          dx = 1;   // 碰撞右侧，向右反弹
      } else {
          dx = (rand() % 3) - 1;  // 碰撞中心，随机调整
      }
  }
  
  // 空格键发射逻辑
  case ' ':
      if (!game_over && !ball_launched) {
          ball_launched = true;
          dx = (rand() % 3) - 1;  // 随机x方向速度
          dy = -1;
      }
      break;
  ```

- **与现有代码的集成方式**：
  - 保持原有游戏逻辑框架不变
  - 仅修改弹珠运动和碰撞检测相关代码
  - 兼容双缓冲技术，不影响视觉效果

#### 测试方法

1. **编译测试**：
   ```bash
   gcc -o ball_game ball_game_thread.c -lncurses -lpthread
   ```
   预期结果：编译成功，无报错

2. **运行测试**：
   ```bash
   ./ball_game
   ```
   预期结果：游戏正常运行，无崩溃

3. **功能测试**：
   - 检查弹珠是否固定在挡板上
   - 检查弹珠是否随挡板移动
   - 检查按下空格键后弹珠是否发射
   - 检查碰撞挡板时是否产生不同的反弹方向
   - 检查游戏是否正常结束和重新开始

#### 变更日期
2025-12-08

### 10.3 新增功能记录_序号003

#### 功能名称
砖块系统实现

#### 功能描述
在游戏区域顶部添加5排砖块，每个砖块由5个'@'横向组成，砖块之间上下左右各有1个空白间距。弹珠碰撞砖块后，砖块立即消失，弹珠按照与挡板和边界相同的反弹逻辑反弹。砖块数量根据游戏区域宽度自动计算，确保完整适配不同屏幕尺寸。

#### 业务逻辑设计思路
1. **砖块布局设计**：在游戏区域顶部创建5排砖块，每排砖块数量动态计算
2. **砖块绘制机制**：使用二维数组存储砖块状态，只绘制存在的砖块
3. **碰撞检测逻辑**：检测弹珠与砖块的矩形碰撞，碰撞后立即销毁砖块
4. **反弹机制**：保持与现有碰撞逻辑一致，确保游戏体验连贯性

#### 技术实现方案及方法

- **修改的文件**：`ball_game_thread.c`

- **新增的变量和常量**：
  ```c
  #define BRICK_ROWS 5  // 砖块行数
  #define BRICK_WIDTH 5  // 每个砖块的宽度（5个'@'）
  #define BRICK_HEIGHT 1  // 每个砖块的高度
  #define BRICK_SPACING 1  // 砖块之间的间距
  bool bricks[BRICK_ROWS][100];  // 砖块状态数组
  int brick_cols;  // 每行砖块数量
  ```

- **修改的函数**：
  1. **new_game函数**：
     - 初始化5排砖块，设置初始状态为存在
     - 动态计算每行砖块数量
  
  2. **paint_thread函数**：
     - 添加砖块绘制逻辑
     - 实现砖块碰撞检测和处理

- **核心实现代码**：
  ```c
  // 初始化砖块
  brick_cols = (game_width - BRICK_SPACING) / (BRICK_WIDTH + BRICK_SPACING);
  for (int i = 0; i < BRICK_ROWS; i++) {
      for (int j = 0; j < brick_cols; j++) {
          bricks[i][j] = true;
      }
  }
  
  // 绘制砖块
  for (int i = 0; i < BRICK_ROWS; i++) {
      for (int j = 0; j < brick_cols; j++) {
          if (bricks[i][j]) {
              int brick_x = left_bound + BRICK_SPACING + j * (BRICK_WIDTH + BRICK_SPACING);
              int brick_y = BRICK_SPACING + i * (BRICK_HEIGHT + BRICK_SPACING);
              for (int k = 0; k < BRICK_WIDTH; k++) {
                  mvwaddch(bg_win, brick_y, brick_x + k, '@');
              }
          }
      }
  }
  
  // 砖块碰撞检测
  if (ballx >= brick_x && ballx <= brick_right && 
      bally >= brick_y && bally <= brick_bottom) {
      bricks[i][j] = false;  // 销毁砖块
      // 弹珠反弹
      if (ballx == brick_x || ballx == brick_right) dx = -dx;
      if (bally == brick_y || bally == brick_bottom) dy = -dy;
  }
  ```

- **与现有代码的集成方式**：
  - 保持原有游戏逻辑框架不变
  - 砖块绘制和碰撞检测与现有游戏循环无缝集成
  - 兼容双缓冲技术和弹珠发射机制

#### 测试方法

1. **编译测试**：
   ```bash
   gcc -o ball_game ball_game_thread.c -lncurses -lpthread
   ```
   预期结果：编译成功，无报错

2. **运行测试**：
   ```bash
   ./ball_game
   ```
   预期结果：游戏正常运行，显示5排砖块

3. **功能测试**：
   - 检查砖块布局是否正确，间距是否合适
   - 测试弹珠碰撞砖块后是否消失
   - 检查弹珠反弹逻辑是否正常
   - 测试游戏流程是否完整

#### 变更日期
2025-12-08

### 10.4 新增功能记录_序号004

#### 功能名称
计分系统实现

#### 功能描述
添加完整的计分系统，玩家每次碰撞砖块时分数加1，实时分数显示在游戏界面左下角（距离底部向上5个字符，距离左侧边界向右3个字符）。分数在游戏开始和重新开始时自动重置为0，为玩家提供直观的游戏进度反馈。

#### 业务逻辑设计思路
1. **分数存储**：使用全局变量记录当前分数
2. **分数更新**：在砖块碰撞事件中自动增加分数
3. **分数显示**：在游戏主循环中实时绘制分数
4. **分数重置**：游戏开始和重新开始时初始化分数为0

#### 技术实现方案及方法

- **修改的文件**：`ball_game_thread.c`

- **新增的变量**：
  ```c
  int score;  // 当前分数
  ```

- **修改的函数**：
  1. **new_game函数**：
     - 初始化分数为0
  
  2. **paint_thread函数**：
     - 添加分数显示逻辑
     - 位置：屏幕左下角，距离底部向上5个字符，距离左侧边界向右3个字符
  
  3. **砖块碰撞检测**：
     - 每次碰撞砖块时分数加1

- **核心实现代码**：
  ```c
  // 初始化分数
  score = 0;
  
  // 分数增加逻辑
  if (ballx >= brick_x && ballx <= brick_right && 
      bally >= brick_y && bally <= brick_bottom) {
      bricks[i][j] = false;
      score++;  // 分数加1
  }
  
  // 分数显示
  mvwprintw(bg_win, LINES - 5, 3, "Score: %d", score);
  ```

- **与现有代码的集成方式**：
  - 保持原有游戏逻辑框架不变
  - 分数显示与游戏元素分层绘制
  - 分数更新与砖块碰撞事件无缝集成
  - 兼容双缓冲技术和现有游戏机制

#### 测试方法

1. **编译测试**：
   ```bash
   gcc -o ball_game ball_game_thread.c -lncurses -lpthread
   ```
   预期结果：编译成功，无报错

2. **运行测试**：
   ```bash
   ./ball_game
   ```
   预期结果：游戏正常运行，左下角显示初始分数0

3. **功能测试**：
   - 检查游戏开始时分数是否为0
   - 测试碰撞砖块后分数是否加1
   - 检查分数显示位置是否正确
   - 测试重新开始游戏时分数是否重置为0

#### 变更日期
2025-12-08

### 10.5 新增功能记录_序号005

#### 功能名称
最高分记录功能

#### 功能描述
添加完整的最高分记录系统，初始值设为0。能够自动识别当前轮次分数是否超过最高分，若超过则更新最高分并实时保存到文件；最高分显示在当前分数正上方3个字符位置；支持长期保存，游戏退出后最高分不会丢失，下次游戏启动时自动加载。

#### 业务逻辑设计思路
1. **文件持久化**：使用文件保存最高分，确保数据长期存储
2. **自动读取**：游戏启动时从文件读取最高分
3. **实时更新**：每次得分后检查并更新最高分
4. **及时保存**：最高分变化时立即写入文件
5. **清晰显示**：最高分显示在当前分数正上方，形成对比

#### 技术实现方案及方法

- **修改的文件**：`ball_game_thread.c`

- **新增的变量和常量**：
  ```c
  int high_score;  // 最高分
  #define HIGH_SCORE_FILE ".highscore"  // 保存最高分的文件名
  ```

- **新增的函数**：
  1. **read_high_score()**：从文件读取最高分
  2. **write_high_score()**：将最高分写入文件

- **修改的函数**：
  1. **main函数**：
     - 游戏启动时读取最高分
     - 游戏退出时保存最高分
  
  2. **paint_thread函数**：
     - 添加最高分显示逻辑
     - 位置：当前分数正上方3个字符
  
  3. **砖块碰撞检测**：
     - 每次得分后检查是否更新最高分

- **核心实现代码**：
  ```c
  // 读取最高分
  void read_high_score() {
      FILE *fp = fopen(HIGH_SCORE_FILE, "r");
      if (fp != NULL) {
          fscanf(fp, "%d", &high_score);
          fclose(fp);
      } else {
          high_score = 0;
      }
  }
  
  // 保存最高分
  void write_high_score() {
      FILE *fp = fopen(HIGH_SCORE_FILE, "w");
      if (fp != NULL) {
          fprintf(fp, "%d", high_score);
          fclose(fp);
      }
  }
  
  // 最高分更新逻辑
  if (score > high_score) {
      high_score = score;
      write_high_score();
  }
  
  // 最高分显示
  mvwprintw(bg_win, LINES - 8, 3, "High Score: %d", high_score);
  ```

- **与现有代码的集成方式**：
  - 与计分系统无缝集成
  - 文件操作与游戏逻辑分离
  - 兼容双缓冲技术和现有游戏机制
  - 不影响游戏性能

#### 测试方法

1. **编译测试**：
   ```bash
   gcc -o ball_game ball_game_thread.c -lncurses -lpthread
   ```
   预期结果：编译成功，无报错

2. **运行测试**：
   ```bash
   ./ball_game
   ```
   预期结果：游戏正常运行，显示初始最高分0

3. **功能测试**：
   - 检查游戏启动时是否读取最高分
   - 测试得分超过当前最高分后是否更新
   - 检查最高分是否正确显示在当前分数正上方
   - 测试游戏退出后重新启动，最高分是否保留
   - 检查最高分文件是否正确创建和更新

#### 变更日期
2025-12-08

### 10.6 新增功能记录_序号006

#### 功能名称
动态难度功能

#### 功能描述
实现弹珠速度随当前得分动态提高的功能，每次速度提高30%。基础延迟100ms，每5分提高一次速度，最高速度限制为30ms延迟，确保游戏可玩性。速度与延迟成反比，分数越高，延迟越小，弹珠移动越快。

#### 业务逻辑设计思路
1. **速度与延迟关系**：速度与延迟时间成反比，延迟越小，速度越快
2. **分段提高机制**：每5分提高一次速度，避免速度变化过于频繁
3. **比例控制**：每次速度提高30%，对应延迟减少约23%
4. **上限限制**：设置最低延迟30ms，防止速度过快无法游玩
5. **平滑过渡**：渐进式难度提升，玩家更容易适应

#### 技术实现方案及方法

- **修改的文件**：`ball_game_thread.c`

- **新增的函数**：
  ```c
  long calculate_delay(int score);  // 动态计算延迟时间
  ```

- **修改的函数**：
  1. **paint_thread函数**：
     - 添加动态延迟计算逻辑
     - 每次循环结束时更新延迟时间

- **核心实现代码**：
  ```c
  long calculate_delay(int score) {
      // 基础延迟100ms，每5分速度提高30%
      long delay = 100;
      int speed_increase_count = score / 5;  // 每5分提高一次速度
      
      // 每次速度提高30%，延迟 = 延迟 * 0.77
      for (int i = 0; i < speed_increase_count; i++) {
          delay = (long)(delay * 0.77);  // 每次减少约23%的延迟
          if (delay < 30) break;
      }
      
      return (delay < 30) ? 30 : delay;
  }
  
  // 在paint_thread中使用
  delay = calculate_delay(score);
  usleep(delay * 1000);
  ```

- **与现有代码的集成方式**：
  - 与计分系统无缝集成
  - 不影响其他游戏机制
  - 兼容双缓冲技术
  - 代码结构清晰，易于维护

#### 测试方法

1. **编译测试**：
   ```bash
   gcc -o ball_game ball_game_thread.c -lncurses -lpthread
   ```
   预期结果：编译成功，无报错

2. **运行测试**：
   ```bash
   ./ball_game
   ```
   预期结果：游戏正常运行，速度随得分提高

3. **功能测试**：
   - 得分0-4：100ms延迟（初始速度）
   - 得分5-9：77ms延迟（速度+30%）
   - 得分10-14：59ms延迟（速度+69%）
   - 得分15-19：46ms延迟（速度+117%）
   - 得分20+：30ms延迟（最大速度）
   - 验证最高速度是否限制在合理范围内

#### 变更日期
2025-12-08

### 10.7 新增功能记录_序号007

#### 功能名称
降低游戏难度

#### 功能描述
将游戏的动态难度增长比率从每次30%调整为3%，使弹珠速度随分数提高更加平缓，降低游戏难度，提高可玩性。保持原有的速度提升机制不变，仅调整提升比率。

#### 业务逻辑设计思路
1. **速度与延迟关系**：速度与延迟时间成反比，延迟越小，速度越快
2. **分段提高机制**：保持每5分提高一次速度的机制
3. **比例调整**：将每次速度提高比率从30%调整为3%，对应延迟减少从23%调整为约2.9%
4. **上限限制**：保持最低延迟30ms的限制不变
5. **平滑过渡**：渐进式难度提升，玩家更容易适应

#### 技术实现方案及方法

- **修改的文件**：`ball_game_thread.c`

- **修改的函数**：
  1. **calculate_delay函数**：
     - 将延迟调整系数从0.77（对应速度提升30%）改为0.9709（对应速度提升3%）
     - 更新函数注释，说明新的速度提升比率

- **核心实现代码**：
  ```c
  // 动态计算延迟时间（根据分数调整难度）
  long calculate_delay(int score) {
      // 基础延迟100ms，每5分速度提高3%（延迟减少约2.9%），最低30ms
      long delay = 100;
      int speed_increase_count = score / 5;  // 每5分提高一次速度
      
      // 每次速度提高3%，延迟 = 延迟 * 0.9709（因为速度与延迟成反比）
      for (int i = 0; i < speed_increase_count; i++) {
          delay = (long)(delay * 0.9709);  // 每次减少约2.9%的延迟
          if (delay < 30) {
              break;  // 达到最低延迟，停止减少
          }
      }
      
      if (delay < 30) {
          delay = 30;
      }
      return delay;
  }
  ```

- **与现有代码的集成方式**：
  - 仅修改速度计算逻辑，不影响其他游戏机制
  - 保持与计分系统的无缝集成
  - 兼容双缓冲技术和现有游戏机制
  - 代码结构清晰，易于维护

#### 测试方法

1. **编译测试**：
   ```bash
   gcc -o ball_game ball_game_thread.c -lncurses -lpthread
   ```
   预期结果：编译成功，无报错

2. **运行测试**：
   ```bash
   ./ball_game
   ```
   预期结果：游戏正常运行，速度随得分平缓提高

3. **功能测试**：
   - 得分0-4：100ms延迟（初始速度）
   - 得分5-9：97.09ms延迟（速度+3%）
   - 得分10-14：94.26ms延迟（速度+6.09%）
   - 得分15-19：91.52ms延迟（速度+9.27%）
   - 得分20-24：88.86ms延迟（速度+12.55%）
   - 验证速度增长是否更加平缓
   - 验证最高速度是否限制在30ms延迟

#### 变更日期
2025-12-08

### 10.8 新增功能记录_序号008

#### 功能名称
砖块刷新功能

#### 功能描述
实现砖块自动刷新机制，当场上所有砖块被清除时，自动生成新的3-7行随机砖块，使游戏可以无限延续，增加游戏的可玩性和挑战性。

#### 业务逻辑设计思路
1. **砖块检测**：实时检测场上是否还有砖块存在
2. **触发条件**：当所有砖块被清除时，触发刷新机制
3. **随机生成**：新生成的砖块行数在3-7之间随机
4. **无缝衔接**：砖块刷新过程不影响游戏流畅性
5. **用户反馈**：刷新时发出声音提示，告知玩家砖块已刷新

#### 技术实现方案及方法

- **修改的文件**：`ball_game_thread.c`

- **新增的常量和变量**：
  ```c
  #define BRICK_MAX_ROWS 7  // 最大砖块行数
  int brick_rows;  // 当前砖块行数（3-7之间随机）
  ```

- **新增的函数**：
  1. **check_bricks_remaining()**：
     - 检查场上是否还有砖块存在
     - 返回true表示还有砖块，false表示所有砖块已被清除

- **修改的函数**：
  1. **new_game函数**：
     - 将固定行数改为随机生成3-7行
     - 使用动态的brick_rows变量初始化砖块

  2. **paint_thread函数**：
     - 更新砖块绘制逻辑，使用动态的brick_rows变量
     - 更新砖块碰撞检测逻辑，使用动态的brick_rows变量
     - 添加砖块刷新逻辑，当所有砖块被清除时生成新砖块

- **核心实现代码**：
  ```c
  // 检查场上是否还有砖块
  bool check_bricks_remaining() {
      for (int i = 0; i < brick_rows; i++) {
          for (int j = 0; j < brick_cols; j++) {
              if (bricks[i][j]) {
                  return true;  // 还有砖块存在
              }
          }
      }
      return false;  // 所有砖块都已销毁
  }

  // 砖块刷新逻辑（在paint_thread中）
  if (!check_bricks_remaining()) {
      // 随机生成新的砖块行数（3-7之间）
      brick_rows = (rand() % 5) + 3;  // 3到7行（含）
      // 初始化新的砖块
      for (int i = 0; i < brick_rows; i++) {
          for (int j = 0; j < brick_cols; j++) {
              bricks[i][j] = true;
          }
      }
      beep();  // 发出声音提示
  }
  ```

- **与现有代码的集成方式**：
  - 与原有的砖块系统无缝集成
  - 不影响其他游戏机制
  - 兼容双缓冲技术
  - 代码结构清晰，易于维护

#### 测试方法

1. **编译测试**：
   ```bash
   gcc -o ball_game ball_game_thread.c -lncurses -lpthread
   ```
   预期结果：编译成功，无报错

2. **运行测试**：
   ```bash
   ./ball_game
   ```
   预期结果：游戏正常运行，砖块显示正常

3. **功能测试**：
   - 清除所有砖块，观察是否生成新的3-7行随机砖块
   - 验证新生成的砖块行数是否在3-7之间
   - 检查砖块刷新时是否发出声音提示
   - 测试多次刷新后游戏是否正常运行

#### 变更日期
2025-12-08

## 11. 新增功能标准化记录模板

### 11.1 新增功能记录格式
```
### [功能名称]

#### 功能描述
[详细描述新增功能的作用、使用场景等]

#### 业务逻辑设计思路
[描述功能的业务流程、逻辑关系等]

#### 技术实现方案及方法
[描述具体的代码实现方案，包括：
- 需要修改的文件和函数
- 新增的变量、函数或类
- 核心实现代码片段
- 与现有代码的集成方式]

#### 测试方法
[描述如何测试该功能，包括测试用例、预期结果等]

#### 变更日期
[YYYY-MM-DD]
```