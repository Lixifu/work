# 实验二：利用多线程实现弹球游戏

## 实验过程记录

### 1. 实验准备
- 阅读实验二内容，理解了多线程弹球游戏的实现要求
- 制定了详细的实验实施计划
- 准备了必要的工具：gcc编译器、文本编辑器

### 2. 代码编写
- 创建了`ball_game_thread.c`文件，实现了多线程弹球游戏功能
- 代码结构包括：
  - 全局变量定义（球、挡板、速度、游戏状态和互斥锁）
  - 游戏初始化函数 `new_game()`
  - 绘图线程函数 `paint_thread()`
  - 主函数 `main()`

### 3. 编译命令
```bash
gcc ball_game_thread.c -o ball_game_thread -lcurses -lpthread
```

### 4. 预期运行结果

| 测试项目 | 预期结果 |
|---------|---------|
| 线程创建 | 成功创建绘图线程 |
| 球的运动 | 球以随机方向开始运动，速度恒定 |
| 碰撞检测 | 球碰到墙壁或挡板会反弹 |
| 挡板控制 | 可通过方向键左右控制挡板 |
| 游戏结束 | 球落地后显示游戏结束信息 |
| 重新开始 | 按'n'键可重新开始游戏 |
| 退出游戏 | 按'q'键可退出程序 |
| 多线程同步 | 主线程和子线程能正确同步，无冲突 |

## 预期功能说明

1. **多线程结构**：
   - 主线程：处理用户输入，控制挡板移动和游戏状态
   - 绘图线程：负责屏幕绘制、球的运动和碰撞检测

2. **线程同步**：
   - 使用互斥锁 `pthread_mutex_t mutex` 保护共享变量
   - 在访问共享资源前加锁，访问后解锁
   - 确保线程安全，避免竞态条件

3. **游戏规则**：
   - 球的初始方向随机
   - 挡板每次移动1格
   - 碰撞边界或挡板后反弹
   - 球落地后游戏结束

4. **视觉效果**：
   - 球用'O'表示
   - 挡板用'**********'表示
   - 游戏结束显示提示信息

## 预期数据分析

1. **线程性能**：
   - 绘图线程周期：100毫秒
   - 主线程响应时间：即时
   - 线程切换开销：低

2. **同步机制**：
   - 互斥锁使用正确
   - 避免了死锁
   - 共享资源访问安全

3. **游戏体验**：
   - 操作流畅
   - 画面刷新稳定
   - 响应速度快

## 实验结论预期

1. **实验成果**：
   - 成功实现了多线程弹球游戏
   - 掌握了pthread库的基本使用方法
   - 学会了线程同步和互斥锁的使用
   - 理解了多线程编程的基本原理

2. **技术要点**：
   - 线程创建和管理
   - 互斥锁的使用
   - 共享资源保护
   - 异步事件处理

3. **实验体会**：
   - 多线程编程需要注意线程同步和共享资源保护
   - 合理的线程分工可以提高程序性能
   - 互斥锁的使用要避免死锁和性能问题
   - 多线程编程可以实现更复杂的程序逻辑

## 问题与解决方案

| 问题 | 解决方案 |
|------|---------|
| 线程安全 | 使用互斥锁保护共享资源 |
| 死锁问题 | 确保每个锁都能正确释放 |
| 响应延迟 | 优化线程调度和休眠时间 |
| 资源泄漏 | 正确释放线程和互斥锁资源 |

## 改进建议

1. **添加速度调节功能**：
   - 按'f'键加速
   - 按's'键减速

2. **添加得分系统**：
   - 碰撞挡板加分
   - 显示当前得分

3. **优化线程同步**：
   - 减少锁的持有时间
   - 使用更细粒度的锁

4. **添加更多游戏元素**：
   - 砖块
   - 道具
   - 多关卡设计
