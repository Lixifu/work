这是一个非常经典的\*\*多线程死锁（Deadlock）\*\*问题。

### 核心原因

你的程序在按 'n' 键后“卡死”，是因为**主线程对自己进行了重复加锁**。

1.  **在 `main` 函数中：**
    当检测到按键 'n' 时，代码进入了 `if (input != ERR)` 分支，随即调用了 `pthread_mutex_lock(&mutex);`（**第1次加锁**，此时主线程持有锁）。
2.  **调用 `new_game()`：**
    在持有锁的情况下，主线程调用了 `new_game()` 函数。
3.  **在 `new_game` 函数中：**
    函数内部第一行又调用了 `pthread_mutex_lock(&mutex);`（**第2次尝试加锁**）。

**结果：**
Linux 默认的互斥锁（Mutex）是**不可递归**的（Non-recursive）。这意味着，如果一个线程已经拿到了锁，它不能再次去拿同一个锁，否则它会停在那里等待自己释放锁。因为主线程卡在了 `new_game` 的加锁语句上，它永远无法执行后面的代码，也永远无法释放锁。

同时，绘图线程（paint\_thread）也因为拿不到锁（被主线程永久占用了）而停止更新画面。这就造成了按 'n' 或 'q' 都没反应的假象（实际上程序已经挂起了）。

-----

### 解决方案

你需要将锁的控制权完全交给调用者（`main` 函数），而不要在 `new_game` 内部加锁。

#### 修改步骤 1：删除 `new_game` 中的锁

修改 `new_game` 函数，去掉内部的 lock 和 unlock。因为这个函数总是被 `main` 调用，我们让 `main` 负责保护它。

```c
// 修改后的 new_game 函数
void new_game()
{
    // pthread_mutex_lock(&mutex);  <-- 删除这行
    
    // ... 初始化代码保持不变 ...
    ballx = COLS / 2;
    bally = LINES / 2;
    dx = (rand() % 2) ? 1 : -1;
    dy = (rand() % 2) ? 1 : -1;
    ball = 'O';
    
    barx = COLS / 2 - 5;
    bary = LINES - 1;
    barlength = 10;
    bar = "**********";
    
    game_over = false;
    
    // pthread_mutex_unlock(&mutex); <-- 删除这行
}
```

#### 修改步骤 2：在 `main` 函数初始化时加锁

因为你删除了 `new_game` 内部的锁，所以 `main` 函数里**第一次调用** `new_game` 时（游戏开始前），需要手动加锁保护。

而在 `while` 循环里按 'n' 重启时，因为外层已经有锁了，所以直接调用即可。

```c
int main()
{
    // ... 前面的初始化代码不变 ...
    
    pthread_mutex_init(&mutex, NULL);
    
    // 【修改处】第一次开始游戏，需要手动加锁保护
    pthread_mutex_lock(&mutex);
    new_game();
    pthread_mutex_unlock(&mutex);
    
    // ... 创建线程代码不变 ...

    while (true) {
        input = getch();
        
        if (input == 'q' || input == 'Q') {
            break;
        }
        
        if (input != ERR) {
            pthread_mutex_lock(&mutex); // 这里加上了锁
            
            switch (input) {
                // ... 其他 case ...
                case 'n': 
                case 'N': 
                    new_game(); // 这里直接调用，不需要new_game内部再加锁了
                    break;
            }
            
            pthread_mutex_unlock(&mutex); // 这里释放锁
        }
        usleep(50000);
    }
    
    // ... 结尾代码不变 ...
}
```

### 总结

你原本的代码逻辑是：

  * Main: Lock -\> Call `new_game` (Lock -\> Wait forever...)

修改后的逻辑是：

  * Main: Lock -\> Call `new_game` (Reset vars) -\> Unlock.

这样修改后，按 'n' 就能正常重置游戏，按 'q' 也能正常退出了（因为主线程不再阻塞，能继续运行到 break 语句）。