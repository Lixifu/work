# 第 10 章 事件驱动编程

## 10.1 实验目的



* 了解 curses 库和 curses 库函数。

* 学习屏幕管理、使用定时器和信号实现进程的并发执行。

* 学会异步事件驱动编程。

* 利用上述知识编写一个视频动画游戏。

## 10.2 背景知识

### 10.2.1 视频游戏的概念

设计一个视频游戏需要综合应用一些概念和原则。游戏程序必须在计算机屏幕的特定位置画出影像，这涉及空间位置处理；游戏程序要在特定的时间触发某些事件，让影像以不同的速度在屏幕上移动，以特定的时间间隔改变位置，这需要获知时间；影像在屏幕上平滑地移动和变化，用户在任意时刻输入信息希望游戏作出反应，这意味着游戏程序应该在保持几个影像移动的同时还要及时响应中断，也就是说，它必须并发执行多个事件。

对于操作系统来说，运行视频游戏程序同样要面临这些问题。内核将游戏程序加载到主存空间并维护不同功能的程序段在主存中的位置；在内核的调度下，程序段以时间片轮流方式运行，同时，内核也在特定的时刻运行特定的内核任务；内核必须在很短的时间内响应用户通过外部设备在任何时刻的输入。由于 “同时” 要并发执行多任务，内核必须确保这些任务的安全性、协调性和及时性。本章将利用 curses 库完成一个基于字符界面的动画游戏。

### 10.2.2 curses 库的历史

curses 是一个函数库，包含许多库函数，专门用来进行 UNIX 终端环境下的屏幕界面处理及 I/O 处理。通过这些库函数，C 和 C++ 程序就可以控制终端的视频显示以及输入输出。使用 curses 库中的函数，用户可以非常方便地创建和操作窗口，使用菜单及表单，而且最为重要的一点是使用 curses 库编写的程序将独立于各种具体终端，这样一个直接的好处就是程序具有良好的可移植性。这一点在网络上显得尤其重要，因为面对的可能是上百种终端，如果为每一个终端都专门编写一套新程序，复杂程度超乎想像，而且几乎不可能实现。

为此，curses 库使用终端描述数据库 terminfo（TERMinal INFOrmation database）或 termcap（TERMinal CAPability database），这两个数据库里存放不同终端的操作控制码、转义序列及其余相关信息。这样，使用每一个终端时，curses 库将首先在终端描述数据库中查找是否存在该类型的终端描述信息，如果找到则进行适当的处理；如果数据库中没有这种终端信息，则程序无法在该终端上运行，除非用户自己增加新的终端描述。curses 库还可以管理键盘，提供一种简单易用的非阻塞字符输入模式。curses 库可以看成是介于简单的文本行程序和完全图形化界面的 X 视窗系统程序之间的一个过渡。

curses 库的名称起源于 “cursor optimization”，即光标优化的意思，它能够优化光标的移动并减少需要对屏幕进行的刷新，最早是由美国加州大学伯克利分校的 Bill Joy 和 Ken Arnold 研究和开发的，主要用于处理游戏 rogue 的屏幕界面。rogue 是一个古老的基于文本的冒险类游戏，在当时，仅仅控制游戏屏幕的外观显示就需要编写大量代码，因为它们使用的是早期的 termios 甚至是 tty 接口。巨大的工作量迫使 Bill Joy 和 Ken Arnold 将 rogue 游戏中的所有屏幕处理和光标移动的函数汇集到函数库中，这就形成早期简单的 curses 函数库的雏形。它最终随着 BSD UNIX 的早期版本发行开来，在这个版本中使用的是当时业已存在的 termcap 数据库来描述终端信息。

后来美国 AT\&T 公司贝尔实验室的 Mark Horton 在 System III UNIX 中重新编写了 curses 库，它相对以前的版本有很大扩展和提高，增加了许多新的特性。首先将 termcap 数据库改进为 terminfo 数据库，terminfo 数据库完全由 Horton 开发编写，它是从 termcap 发展而来，而且更为重要的是其中引进参数化性能的概念，这样使得描述多视频属性以及彩色终端成为可能。在后来的 AT\&T System V UNIX 版本中，curses 库扩展出更多功能和性能，包括对窗体、菜单、面板、表单等组件以及对鼠标的支持。至此 curses 库内容以及设计与最初 BSD 版本的 curses 库在功能和复杂性上已经相去甚远。

Linux 使用的 curses 库版本是 ncurses（new curses）。对 curses 库的程序进行编译时，必须在程序中包含头文件 curses.h，同时需要在编译命令行中用 - lcurses 选项对 curses 库进行链接。在许多 Linux 系统中，curses 头文件和库文件是对 ncurses 对应文件的链接。

### 10.2.3 使用 curses 库

#### 10.2.3.1 curses 屏幕

curses 程序工作在屏幕、窗口和子窗口上。“屏幕” 指的是正在写的设备（通常是终端屏幕、也可能是 xterm 屏幕）。curses 库将终端屏幕看成是由字符单元组成的网格，每一个单元由（行、列）坐标对标示，坐标系的原点是屏幕的左上角，行坐标自上而下递增，列坐标自左向右递增（如图 10-1 所示）。无论何时，至少存在一个 curses 窗口，称为 stdscr，它与物理屏幕的尺寸完全一样。除了 stdscr 之外，还可以拥有多个子窗口。这些子窗口可以互相重叠，并且还可以拥有各自的子窗口，各自的子窗口总是被包含在其父窗口内。



![图10-1 curses屏幕](示意图：坐标\(0,0\)为左上角，move\(5,9\)表示移动到第5行第9列，addstr\("hello"\)在该位置输出"hello")

curses 库用两个数据结构来映射终端屏幕，分别是 stdscr 和 curscr。stdscr 结构表示是一个逻辑屏幕，它的显示内容在终端屏幕上不一定能够立即看得到，curscr 对应的是实际看到的物理屏幕。在使用 curses 库函数时，函数更新的是 stdscr 结构，即逻辑屏幕。逻辑屏幕是终端应该呈现的内容，它和当前终端的实际内容是有区别的。在调用 refresh () 函数之前，输出到 stdscr 上的内容不会显示在屏幕上。调用 refresh () 函数时，curses 库会比较 stdscr 和 curscr 之间的不同之处，然后通过两个数据结构之间的差异来刷新屏幕。一旦更新，curscr 将显示 stdscr 上的内容，这样当前屏幕上反映的内容就与标准屏幕上的一样（如图 10-2、图 10-3 所示）。

综上所述，在使用 curses 库时，输出字符的过程如下：

① 用 curses 相关函数更新逻辑屏幕（stdscr）；

② 用 refresh () 函数刷新物理屏幕（curscr）。

在 10.2.2 小节中曾经提到，curses 库的产生是为了能够优化光标的移动并减少需要对屏幕进行的刷新。通过比较 stdscr 和 curscr，curses 库能够判断出两者之间的差异，并通过差异来刷新屏幕。通过这样的刷新步骤，curses 屏幕的刷新效率很高，虽然这点效率对于控制台屏幕来说意义不大，但是如果是通过慢速串行接口或者调制解调器连接到主机上来运行程序，则屏幕刷新效率的提高意义就很大了。



![图10-2 stdscr 和 curscr关系(1)](示意图：展示initscr\(\)、move\(\)、addstr\("Eye"\)、refresh\(\)、endwin\(\)等操作下stdscr和curscr的状态变化)



![图10-3 stdscr 和 curscr关系(2)](示意图：展示在已有"Eye"的基础上，move\(\)、addstr\("Bulls"\)、refresh\(\)等操作下stdscr和curscr的状态变化)

一个 curses 程序会多次调用逻辑屏幕输出函数，例如在屏幕上移动光标到达正确的位置，然后输出文本、绘制线框。curses 库函数使用的坐标是 y 值（行号）在前、x 值（列号）在后。每个位置不仅包含该屏幕位置处的字符，还包含其属性，可实现的属性依赖于物理终端的性能指标，但一般至少会支持粗体和下划线这两个属性。在 Linux 控制台上，通常还支持反白显示和均匀彩色属性。

#### 10.2.3.2 初始化和重置函数

由于 curses 库在使用时需要创建和删除一些临时数据结构，所以 curses 程序必须在开始使用时进行初始化，并在结束时删除这些资源。这两项工作通过 initscr () 和 endwin () 函数分别完成。在使用这些函数时，需要包含头文件 curses.h。大体框架如下：



```
\#include \<curses.h>

int main(int argc, char\*\* argv)

{

&#x20;   initscr();

&#x20;   // 程序核心逻辑

&#x20;   endwin();

&#x20;   return 0;

}
```

这两个函数的原型为：



```
\#include \<curses.h>

WINDOW \*initscr(void);

int endwin(void);
```

initscr () 函数在一个程序中只能调用一次。如果成功，initscr () 函数返回一个指向 stdscr 结构的指针；如果失败，简单输出一条诊断错误信息并使程序结束。endwin () 函数在成功时返回 OK，失败时返回 ERR。endwin () 函数还有一个用法是能够强制 curses 库重新重写屏幕。调用 refresh () 函数时，curses 库只是比较 stdscr 和 curscr 的差异重写屏幕。如果要将 stdscr 的内容完整重写到 curscr 上，可以先调用 endwin () 函数退出 curses 库，然后通过调用 clearok (stdscr, 1) 和 refresh () 函数继续 curses 操作。这样实际上是首先让 curses 库忘记物理屏幕的内容，然后强迫它执行一次完整的屏幕刷新。

#### 10.2.3.3 屏幕输出和字符属性

curses 库提供一组函数用于将字符输出到屏幕上，主要包括：



```
\#include \<curses.h>

int addch(const chtype char\_to\_add);          // 输出单个字符

int addchstr(chtype \*const string\_to\_add);    // 输出字符串

int printw(char \*format, ...);                // 格式化输出（类似printf）

int insch(chtype char\_to\_insert);             // 在光标位置插入字符（原有字符右移）

int inchstr(chtype \*);                        // 读取光标位置开始的字符串

int insertln(void);                           // 插入空行（现有行下移）

int delch(void);                              // 删除光标位置字符（右侧字符左移）

int deleteln(void);                           // 删除当前行（现有行上移）

int beep(void);                               // 发声提示

int flash(void);                               // 闪烁屏幕提示

int refresh();                                 // 刷新物理屏幕
```

curses 库使用的字符类型为 chtype，在 Linux 中的定义为：



```
typedef unsigned long chtype;
```

在这个定义下，chtype（32 位）能够表示的字符数量比 char（8 位）更多。

addch ()、addchstr () 和 printw () 函数都从当前光标开始输出字符或字符串。addch () 用于输出单个字符，addchstr () 可以输出一个字符串。如果需要对输出的字符串进行格式化，达到类似 printf () 的效果，则需要使用 printw () 函数，该函数的使用方法和 printf () 函数一致。在使用这 3 个函数时，如果当前光标位置已有字符，则字符会被新字符覆盖。如果不希望覆盖光标所在位置的字符，则可以使用 insch () 函数，该函数在光标所在位置插入一个字符，原先的字符则向右移。inchstr () 用于读取光标位置开始的字符串，insertln () 函数可以插入一个空行，并将现有行下移。与 insch () 函数对应的是 delch () 函数，该函数能够删除光标所在位置的字符，并将光标右边的字符左移。insertln () 对应的函数是 deleteln ()，该函数删除一行，并将现有行上移。

程序还可以利用 curses 库对用户进行提示，有两种提示方法：发声和闪烁屏幕，对应的函数为 beep () 和 flash ()。有些终端并不支持发声，在这种情况下，beep () 函数会尝试让屏幕闪烁；如果使用 flash () 函数但终端无法产生效果，则 flash () 函数会尝试在终端上发出声音。

在往屏幕输出完毕后，程序必须通过 refresh () 函数让 curses 库根据 stdscr 和 curscr 的差异刷新屏幕。

在输出时，每个 curses 字符都可以有特定的属性，该属性控制着字符在屏幕上的显示方式（前提是硬件设备支持该属性）。预定义的属性有 A\_BLINK（闪烁）、A\_BOLD（粗体）、A\_DIM（暗淡）、A\_REVERSE（反白）、A\_STANDOUT（突出）和 A\_UNDERLINE（下划线）。curses 库提供了一组函数用于设置字符属性：



```
\#include \<curses.h>

int attron(chtype attribute);   // 开启指定属性

int attroff(chtype attribute);  // 关闭指定属性

int attrset(chtype attribute);  // 设置指定属性（覆盖原有属性）

int standout(void);             // 开启“突出”模式（通常为反白显示）

int standend(void);             // 关闭“突出”模式
```

当设置好 curses 字符属性后，接下来输出的字符都将以指定的属性输出。例如：



```
attron(A\_BOLD);                 // 打开粗体

printw("%s", "BOLD");           // "BOLD" 将以粗体显示

attroff(A\_BOLD);                // 关闭粗体

printw("%s", "hello");          // "hello" 将不以粗体显示
```

#### 10.2.3.4 移动光标、清除屏幕

curses 库在往屏幕输出字符时，是在当前光标位置进行操作。因此为了在指定位置输出字符，需使用光标移动函数：



```
\#include \<curses.h>

int move(int new\_y, int new\_x);  // 移动光标到（new\_y, new\_x）位置
```

需要注意，调用 move () 函数后，光标并不会立即出现在指定位置（因为 curscr 尚未更新），只有执行 refresh () 函数后，光标才会显示在新位置。new\_y 和 new\_x 的取值范围受限制：new\_y 不能超过屏幕的行数，new\_x 不能超过屏幕的列数，屏幕的这两个属性通过外部整数 LINES（行数）和 COLS（列数）定义。

通常在使用 move () 函数之后会调用屏幕输出相关函数进行绘制，curses 库为这种典型操作提供了一系列简化函数（在原有输出函数前添加 mv 前缀，代表 “移动后输出”）：



```
\#include \<curses.h>

int mvaddch(int new\_y, int new\_x, const chtype char\_to\_add);  // 移动后输出单个字符

int mvaddchstr(int new\_y, int new\_x, chtype \*const string\_to\_add);  // 移动后输出字符串

int mvprintw(int new\_y, int new\_x, char \*format, ...);  // 移动后格式化输出
```

curses 库还提供清除屏幕的方法：



```
\#include \<curses.h>

int erase(void);  // 在每个屏幕位置写入空白字符

int clear(void);  // 类似erase()，但会调用clearok()强制重现屏幕原文
```

clearok () 函数会强制执行清屏操作，并在下次调用 refresh () 函数时重现屏幕原文。clear () 函数并不是简单地删除当前屏幕上的非空白位置，因此是一种彻底清除屏幕的可靠方法。clear () 函数后跟 refresh () 函数的组合，提供了一种有效的重新绘制屏幕的方法。

**示例程序：cursestest.c**



```
\#include \<stdio.h>

\#include \<curses.h>

int main(int argc, char\* argv\[])

{

&#x20;   initscr();  // 初始化curses

&#x20;   // 粗体显示

&#x20;   move(10, 20);

&#x20;   attron(A\_BOLD);

&#x20;   addstr("Hello, ");

&#x20;   refresh();

&#x20;   sleep(1);

&#x20;   // 粗体+下划线

&#x20;   attron(A\_UNDERLINE);

&#x20;   addstr("world!");

&#x20;   refresh();

&#x20;   sleep(1);

&#x20;   // 下划线（关闭粗体）

&#x20;   move(11, 20);

&#x20;   attroff(A\_BOLD);

&#x20;   addstr("Hello, ");

&#x20;   refresh();

&#x20;   sleep(1);

&#x20;   // 普通模式（关闭下划线）

&#x20;   attroff(A\_UNDERLINE);

&#x20;   addstr("world!");

&#x20;   refresh();

&#x20;   sleep(1);

&#x20;   // 反白显示

&#x20;   move(12, 20);

&#x20;   standout();

&#x20;   addstr("Hello, world!");

&#x20;   standend();

&#x20;   refresh();

&#x20;   sleep(1);

&#x20;   sleep(10);

&#x20;   endwin();  // 关闭curses

&#x20;   return 0;

}
```

编译命令（需链接 curses 库）：



```
gcc cursestest.c -o test -lcurses
```

#### 10.2.3.5 键盘输入处理

curses 库提供了一组用于读取键盘输入的函数，与标准输入函数对应关系如下：



| 标准输入函数    | curses 输入函数 | 说明               |
| --------- | ----------- | ---------------- |
| getchar() | getch()     | 读取单个字符           |
| gets()    | getstr()    | 读取字符串（不推荐，无长度限制） |
| scanf()   | scanw()     | 格式化读取            |
| -         | getnstr()   | 读取指定长度的字符串（推荐使用） |

**示例程序：passwordtest.c（密码输入保密）**



```
\#include \<unistd.h>

\#include \<stdlib.h>

\#include \<curses.h>

\#include \<string.h>

int main(int argc, char \*argv\[])

{

&#x20;   char name\[20];

&#x20;   char password\[20];

&#x20;   char \*real\_password = "123456";

&#x20;   initscr();  // 初始化curses

&#x20;   // 输入用户名

&#x20;   move(5, 10);

&#x20;   addstr("User name:");

&#x20;   getnstr(name, sizeof(name));  // 读取用户名（限制长度）

&#x20;   // 输入密码（关闭回显）

&#x20;   move(7, 10);

&#x20;   addstr("Password:");

&#x20;   refresh();

&#x20;   cbreak();   // 开启中断模式（无需等待回车，即时读取输入）

&#x20;   noecho();   // 关闭回显（输入字符不显示）

&#x20;   memset(password, 0, sizeof(password));

&#x20;   int len = sizeof(password);

&#x20;   for (int i = 0; i < len; i++) {

&#x20;       password\[i] = getch();  // 读取单个字符

&#x20;       move(7, 20 + i);

&#x20;       addch('\*');  // 显示星号代替密码

&#x20;       refresh();

&#x20;       if (password\[i] == '\n')  // 回车结束输入

&#x20;           break;

&#x20;   }

&#x20;   echo();     // 恢复回显

&#x20;   nocbreak(); // 关闭中断模式

&#x20;   // 验证密码并输出结果

&#x20;   move(9, 10);

&#x20;   if (strcmp(password, real\_password) == 0)

&#x20;       addstr("Correct");

&#x20;   else

&#x20;       addstr("Wrong");

&#x20;   refresh();

&#x20;   endwin();  // 关闭curses

&#x20;   return 0;

}
```

**功能键处理**：

一般键盘包含方向键和功能键，curses 库通过 keypad () 函数启用功能键支持，该函数会接管按键转义序列的处理，返回与逻辑按键对应的 KEY\_前缀定义（如 KEY\_LEFT、KEY\_RIGHT 等）。

keypad () 函数原型：



```
\#include \<curses.h>

int keypad(WINDOW \*window\_ptr, bool keypad\_on);  // keypad\_on=true启用功能键模式
```

**示例程序：keypadtest.c（方向键移动字符）**



```
\#include \<curses.h>

\#define MIN(a,b) (a < b ? a : b)

\#define MAX(a,b) (a > b ? a : b)

int main(int argc, char \*argv\[])

{

&#x20;   int x = 10;    // 字符x坐标

&#x20;   int y = 10;    // 字符y坐标

&#x20;   char ch = 'A'; // 待显示字符

&#x20;   initscr();

&#x20;   cbreak();      // 中断模式

&#x20;   noecho();      // 关闭回显

&#x20;   clear();

&#x20;   keypad(stdscr, TRUE);  // 启用功能键

&#x20;   mvaddch(y, x, ch);     // 初始位置显示字符

&#x20;   chtype input;

&#x20;   while ((input = getch()) && input != ERR && input != 'q') {  // 'q'退出

&#x20;       // 输入字母则更新显示字符

&#x20;       if ((input >= 'A' && input <= 'Z') || (input >= 'a' && input <= 'z')) {

&#x20;           ch = input;

&#x20;       } else {

&#x20;           // 方向键调整坐标

&#x20;           switch (input) {

&#x20;               case KEY\_LEFT:

&#x20;                   x = MAX(x - 1, 0);  // 左边界限制

&#x20;                   break;

&#x20;               case KEY\_RIGHT:

&#x20;                   x = MIN(x + 1, COLS - 1);  // 右边界限制

&#x20;                   break;

&#x20;               case KEY\_UP:

&#x20;                   y = MAX(y - 1, 0);  // 上边界限制

&#x20;                   break;

&#x20;               case KEY\_DOWN:

&#x20;                   y = MIN(y + 1, LINES - 1);  // 下边界限制

&#x20;                   break;

&#x20;           }

&#x20;       }

&#x20;       clear();  // 清除旧字符

&#x20;       mvaddch(y, x, ch);  // 新位置显示字符

&#x20;       refresh();

&#x20;   }

&#x20;   endwin();

&#x20;   return 0;

}
```

## 10.3 实验内容

### 10.3.1 实验 1 利用 curses 库实现弹球游戏

#### 10.3.1.1 实验说明

弹球游戏的界面由墙、球和挡板组成（如图 10-5 所示），主要规则为：



* 球以一定的速度移动。

* 球碰到墙壁或挡板会被弹回。

* 用户通过方向键控制挡板左右移动。



![图10-5 弹球游戏说明](示意图：展示墙、球（O）和挡板的位置关系)

#### 10.3.1.2 解决方案



1. 用 usleep () 函数绘制动画

   弹球游戏中，球在未碰撞时沿直线运动，碰撞后改变方向。动画的实现原理是：在一个位置绘制球，等待若干毫秒，擦除旧球并在新位置重新绘制，循环往复形成运动效果。usleep () 函数可让进程休眠，唤醒后绘制下一帧图像。

**示例程序：exampleprogram1.c（球水平往复运动）**



```
\#include \<curses.h>

\#include \<unistd.h>

int main(int argc, char \*argv\[])

{

&#x20;   int x = 10;        // 球x坐标

&#x20;   int y = 10;        // 球y坐标

&#x20;   int direction = 1; // 运动方向（1：右，-1：左）

&#x20;   char ball = 'O';   // 球的表示字符

&#x20;   // 初始化curses

&#x20;   initscr();

&#x20;   cbreak();

&#x20;   noecho();

&#x20;   while (true) {

&#x20;       clear();               // 清除屏幕

&#x20;       mvaddch(y, x, ball);  // 绘制球

&#x20;       refresh();             // 刷新屏幕

&#x20;       x += direction;        // 更新x坐标

&#x20;       // 碰撞左右边界，改变方向并发声

&#x20;       if (x == COLS - 1) {   // 右边界

&#x20;           direction = -1;

&#x20;           x = COLS - 2;

&#x20;           beep();

&#x20;       }

&#x20;       if (x < 0) {           // 左边界

&#x20;           direction = 1;

&#x20;           x = 0;

&#x20;           beep();

&#x20;       }

&#x20;       usleep(100000);  // 休眠100毫秒（控制运动速度）

&#x20;   }

&#x20;   endwin();

&#x20;   return 0;

}
```



1. 通过定时器绘制动画

   exampleprogram1.c 通过循环休眠实现动画，但无法同时响应用户输入。通过定时器发送 SIGALRM 信号定时刷新屏幕，可实现动画与用户交互的并发。用户可通过按键调整球的运动速度（f 键加速、s 键减速），q 键退出。

**示例程序：exampleprogram2.c（定时器控制动画）**



```
\#include \<curses.h>

\#include \<time.h>

\#include \<sys/time.h>

\#include \<signal.h>

\#include \<unistd.h>

// 球的全局变量（信号处理函数中需访问）

int x = 10;

int y = 10;

int direction = 1;

char ball = 'O';

// 定时器设置函数（n\_msecs：定时周期，单位毫秒）

int set\_ticker(long n\_msecs)

{

&#x20;   struct itimerval new\_timeset;

&#x20;   long n\_sec = n\_msecs / 1000;

&#x20;   long n\_usecs = (n\_msecs % 1000) \* 1000L;

&#x20;   // 设置定时周期（interval）和初始触发时间（value）

&#x20;   new\_timeset.it\_interval.tv\_sec = n\_sec;

&#x20;   new\_timeset.it\_interval.tv\_usec = n\_usecs;

&#x20;   new\_timeset.it\_value.tv\_sec = n\_sec;

&#x20;   new\_timeset.it\_value.tv\_usec = n\_usecs;

&#x20;   return setitimer(ITIMER\_REAL, \&new\_timeset, NULL);  // 启用实时定时器

}

// 信号处理函数（SIGALRM信号触发时绘制图像）

void paint()

{

&#x20;   clear();

&#x20;   mvaddch(y, x, ball);

&#x20;   refresh();

&#x20;   x += direction;

&#x20;   // 碰撞边界处理

&#x20;   if (x == COLS - 1) {

&#x20;       direction = -1;

&#x20;       x = COLS - 2;

&#x20;       beep();

&#x20;   }

&#x20;   if (x < 0) {

&#x20;       direction = 1;

&#x20;       x = 0;

&#x20;       beep();

&#x20;   }

}

int main(int argc, char \*argv\[])

{

&#x20;   chtype input;

&#x20;   long delay = 100;  // 初始定时周期（100毫秒）

&#x20;   // 初始化curses

&#x20;   initscr();

&#x20;   cbreak();

&#x20;   noecho();

&#x20;   // 注册SIGALRM信号处理函数，设置定时器

&#x20;   signal(SIGALRM, paint);

&#x20;   set\_ticker(delay);

&#x20;   // 循环处理用户输入

&#x20;   while ((input = getch()) && input != ERR && input != 'q') {

&#x20;       switch (input) {

&#x20;           case 'f':  // 加速（周期减半）

&#x20;               delay /= 2;

&#x20;               set\_ticker(delay);

&#x20;               break;

&#x20;           case 's':  // 减速（周期加倍）

&#x20;               delay \*= 2;

&#x20;               set\_ticker(delay);

&#x20;               break;

&#x20;       }

&#x20;   }

&#x20;   endwin();

&#x20;   return 0;

}
```



1. 绘制球与挡板

   球的运动自动进行，碰撞墙或挡板后改变方向；挡板由用户通过方向键控制左右移动。

**示例程序：program3.c（球与挡板的绘制与控制）**



```
\#include \<curses.h>

\#include \<stdio.h>

\#include \<time.h>

\#include \<sys/time.h>

\#include \<signal.h>

\#include \<unistd.h>

\#define MAX(a,b) (a > b ? a : b)

\#define MIN(a,b) (a < b ? a : b)

// 球的参数

int ballx = 10;

int bally = 10;

int dx = 1;   // x方向速度（1：右，-1：左）

int dy = 1;   // y方向速度（1：下，-1：上）

char ball = 'O';

// 挡板参数

int barx = 10;          // 挡板x坐标（左起点）

int bary;               // 挡板y坐标（固定在屏幕底部）

char\* bar = "\*\*\*\*\*\*\*\*\*\*";  // 挡板（长度10）

int barlength = 10;     // 挡板长度

// 定时器设置函数

int set\_ticker(long n\_msecs)

{

&#x20;   struct itimerval new\_timeset;

&#x20;   long n\_sec = n\_msecs / 1000;

&#x20;   long n\_usecs = (n\_msecs % 1000) \* 1000L;

&#x20;   new\_timeset.it\_interval.tv\_sec = n\_sec;

&#x20;   new\_timeset.it\_interval.tv\_usec = n\_usecs;

&#x20;   new\_timeset.it\_value.tv\_sec = n\_sec;

&#x20;   new\_timeset.it\_value.tv\_usec = n\_usecs;

&#x20;   return setitimer(ITIMER\_REAL, \&new\_timeset, NULL);

}

// 绘制函数

void paint()

{

&#x20;   clear();

&#x20;   mvaddch(bally, ballx, ball);  // 绘制球

&#x20;   mvaddstr(bary, barx, bar);    // 绘制挡板

&#x20;   refresh();

&#x20;   // 更新球的坐标

&#x20;   ballx += dx;

&#x20;   bally += dy;

&#x20;   // 碰撞左右边界：x方向反向

&#x20;   if (ballx == COLS - 1 || ballx < 0) {

&#x20;       dx = -dx;

&#x20;       beep();

&#x20;   }

&#x20;   // 碰撞上下边界：y方向反向

&#x20;   if (bally < 0) {

&#x20;       dy = -dy;

&#x20;       beep();

&#x20;   }

&#x20;   // 碰撞挡板：y方向反向（判断球的y坐标是否为挡板上方，且x坐标在挡板范围内）

&#x20;   if (bally == bary - 1 && ballx >= barx && ballx < barx + barlength) {

&#x20;       dy = -dy;

&#x20;       beep();

&#x20;   }

&#x20;   // 球落地（未碰到挡板）：游戏结束逻辑（可自行扩展）

&#x20;   if (bally >= LINES - 1) {

&#x20;       dy = 0;

&#x20;       dx = 0;

&#x20;       mvaddstr(LINES/2, COLS/2 - 5, "Game Over!");

&#x20;       refresh();

&#x20;   }

}

int main(int argc, char \*argv\[])

{

&#x20;   chtype input;

&#x20;   long delay = 100;

&#x20;   // 初始化curses

&#x20;   initscr();

&#x20;   cbreak();

&#x20;   noecho();

&#x20;   keypad(stdscr, TRUE);  // 启用方向键

&#x20;   bary = LINES - 1;      // 挡板固定在屏幕底部（最后一行）

&#x20;   // 设置定时器和信号处理

&#x20;   signal(SIGALRM, paint);

&#x20;   set\_ticker(delay);

&#x20;   // 处理用户输入（控制挡板和速度）

&#x20;   while ((input = getch()) && input != ERR && input != 'q') {

&#x20;       switch (input) {

&#x20;           case 'f':  // 加速

&#x20;               delay /= 2;

&#x20;               set\_ticker(delay);

&#x20;               break;

&#x20;           case 's':  // 减速

&#x20;               delay \*= 2;

&#x20;               set\_ticker(delay);

&#x20;               break;

&#x20;           case KEY\_RIGHT:  // 挡板右移（不超出屏幕）

&#x20;               barx = MIN(barx + 1, COLS - 1 - barlength);

&#x20;               break;

&#x20;           case KEY\_LEFT:   // 挡板左移（不超出屏幕）

&#x20;               barx = MAX(barx - 1, 0);

&#x20;               break;

&#x20;       }

&#x20;   }

&#x20;   endwin();

&#x20;   return 0;

}
```

程序运行结果如图 10-6 所示：



![图10-6 球与挡板](示意图：屏幕底部显示挡板，中间显示运动的球)



1. 斜线运动

   弹球游戏中，球需以斜线方式运动（同时改变 x 和 y 坐标）。为保证运动平滑，需每次移动一个单位（x 和 y 各 ±1），避免跨度较大导致的跳跃感。碰撞挡板或墙时，对应方向的速度反向（如碰左右墙则 dx 反向，碰上下墙或挡板则 dy 反向）。

**斜线运动代码框架（需整合到上述程序中）**：



```
// 球的速度参数（初始斜线运动：右下方向）

int dx = 1;

int dy = 1;

// 绘制函数中更新球坐标

ballx += dx;

bally += dy;

// 碰撞检测与方向调整

if (ballx == COLS - 1 || ballx < 0) {

&#x20;   dx = -dx;  // x方向反向

&#x20;   beep();

}

if (bally < 0) {

&#x20;   dy = -dy;  // y方向反向

&#x20;   beep();

}

if (bally == bary - 1 && ballx >= barx && ballx < barx + barlength) {

&#x20;   dy = -dy;  // 碰撞挡板，y方向反向

&#x20;   beep();

}
```

游戏界面参考：



* 启动界面（图 10-9）：显示欢迎信息和操作提示（如 “Help: start a new game”）。

* 结束界面（图 10-10）：显示 “Game Over! Press 'N' to start a new game”。



![图10-9 游戏启动](示意图：屏幕显示欢迎信息和帮助提示)



![图10-10 游戏结束](示意图：屏幕显示游戏结束提示和重新开始按键)

#### 10.3.1.3 程序框架



```
\#include \<curses.h>

\#include \<signal.h>

\#include \<sys/time.h>

\#include \<unistd.h>

// 全局变量定义（球、挡板、速度、游戏状态等）

int ballx, bally, dx, dy;

int barx, bary, barlength;

char ball, \*bar;

bool game\_over;

// 定时器设置函数

int set\_ticker(long n\_msecs)

{

&#x20;   struct itimerval new\_timeset;

&#x20;   long n\_sec = n\_msecs / 1000;

&#x20;   long n\_usecs = (n\_msecs % 1000) \* 1000L;

&#x20;   new\_timeset.it\_interval.tv\_sec = n\_sec;

&#x20;   new\_timeset.it\_interval.tv\_usec = n\_usecs;

&#x20;   new\_timeset.it\_value.tv\_sec = n\_sec;

&#x20;   new\_timeset.it\_value.tv\_usec = n\_usecs;

&#x20;   return setitimer(ITIMER\_REAL, \&new\_timeset, NULL);

}

// 绘制图像函数（SIGALRM信号触发）

void paint()

{

&#x20;   if (game\_over) {

&#x20;       // 绘制游戏结束界面

&#x20;       mvaddstr(LINES/2, COLS/2 - 5, "Game Over!");

&#x20;       mvaddstr(LINES/2 + 1, COLS/2 - 10, "Press 'N' to restart");

&#x20;       refresh();

&#x20;       return;

&#x20;   }

&#x20;   clear();

&#x20;   // 绘制球、挡板、游戏边界等

&#x20;   mvaddch(bally, ballx, ball);

&#x20;   mvaddstr(bary, barx, bar);

&#x20;   refresh();

&#x20;   // 更新球的坐标

&#x20;   ballx += dx;

&#x20;   bally += dy;

&#x20;   // 碰撞检测与处理（边界、挡板、游戏结束）

&#x20;   // ...（实现碰撞逻辑）

}

// 游戏初始化函数

void init\_game()

{

&#x20;   // 初始化球的位置和速度（斜线运动）

&#x20;   ballx = COLS / 2;

&#x20;   bally = LINES / 2;

&#x20;   dx = 1;

&#x20;   dy = 1;

&#x20;   ball = 'O';

&#x20;   // 初始化挡板位置和参数

&#x20;   barx = COLS / 2 - 5;

&#x20;   bary = LINES - 1;

&#x20;   barlength = 10;

&#x20;   bar = "\*\*\*\*\*\*\*\*\*\*";

&#x20;   // 游戏状态

&#x20;   game\_over = false;

}

int main(int argc, char \*argv\[])

{

&#x20;   chtype input;

&#x20;   long delay = 100;

&#x20;   // 初始化curses

&#x20;   initscr();

&#x20;   cbreak();

&#x20;   noecho();

&#x20;   keypad(stdscr, TRUE);

&#x20;   curs\_set(0);  // 隐藏光标

&#x20;   // 初始化游戏

&#x20;   init\_game();

&#x20;   // 设置定时器和信号处理

&#x20;   signal(SIGALRM, paint);

&#x20;   set\_ticker(delay);

&#x20;   // 处理用户输入

&#x20;   while ((input = getch()) && input != ERR && input != 'q') {

&#x20;       switch (input) {

&#x20;           case 'f':  // 加速

&#x20;               delay = MAX(delay / 2, 10);  // 最小延迟10毫秒

&#x20;               set\_ticker(delay);

&#x20;               break;

&#x20;           case 's':  // 减速

&#x20;               delay \*= 2;

&#x20;               set\_ticker(delay);

&#x20;               break;

&#x20;           case KEY\_LEFT:  // 挡板左移

&#x20;               barx = MAX(barx - 1, 0);

&#x20;               break;

&#x20;           case KEY\_RIGHT:  // 挡板右移

&#x20;               barx = MIN(barx + 1, COLS - 1 - barlength);

&#x20;               break;

&#x20;           case 'n':  // 重新开始游戏

&#x20;               init\_game();

&#x20;               break;

&#x20;       }

&#x20;   }

&#x20;   endwin();

&#x20;   return 0;

}
```

### 10.3.2 实验 2 利用多线程实现弹球游戏

#### 10.3.2.1 实验说明

10.3.1 小节的实验通过定时器和信号机制模拟并发（响应用户输入 + 屏幕刷新）。本实验要求通过显式多线程编程实现：主线程处理用户输入，子线程负责屏幕绘制和球的运动逻辑。

#### 10.3.2.2 解决方案

多线程结构设计：



* 主线程：初始化 curses、游戏参数，循环读取用户输入（控制挡板移动、速度调整、重新开始等）。

* 绘图线程：独立运行，通过 usleep () 控制绘制周期，实现球的自动运动、碰撞检测和屏幕刷新。

线程创建使用 pthread 库，需链接 - lpthread 选项。

#### 10.3.2.3 程序框架



```
\#include \<curses.h>

\#include \<string.h>

\#include \<signal.h>

\#include \<time.h>

\#include \<sys/time.h>

\#include \<pthread.h>

\#include \<unistd.h>

\#include \<stdlib.h>

// 全局变量（主线程和子线程共享）

int ballx, bally, dx, dy;

int barx, bary, barlength;

char ball, \*bar;

bool game\_over;

pthread\_mutex\_t mutex;  // 互斥锁（保护共享变量）

// 游戏初始化函数

void new\_game()

{

&#x20;   pthread\_mutex\_lock(\&mutex);  // 加锁保护共享变量

&#x20;   // 初始化球的参数

&#x20;   ballx = COLS / 2;

&#x20;   bally = LINES / 2;

&#x20;   dx = (rand() % 2) ? 1 : -1;  // 随机x方向（左/右）

&#x20;   dy = (rand() % 2) ? 1 : -1;  // 随机y方向（上/下）

&#x20;   ball = 'O';

&#x20;   // 初始化挡板参数

&#x20;   barx = COLS / 2 - 5;

&#x20;   bary = LINES - 1;

&#x20;   barlength = 10;

&#x20;   bar = "\*\*\*\*\*\*\*\*\*\*";

&#x20;   // 游戏状态

&#x20;   game\_over = false;

&#x20;   pthread\_mutex\_unlock(\&mutex);  // 解锁

}

// 绘图线程函数（负责球的运动、碰撞检测和屏幕绘制）

void\* paint\_thread(void\* arg)

{

&#x20;   long delay = 100;  // 绘制周期（毫秒）

&#x20;   while (true) {

&#x20;       pthread\_mutex\_lock(\&mutex);  // 加锁

&#x20;       if (!game\_over) {

&#x20;           clear();

&#x20;           // 绘制球和挡板

&#x20;           mvaddch(bally, ballx, ball);

&#x20;           mvaddstr(bary, barx, bar);

&#x20;           refresh();

&#x20;           // 更新球的坐标

&#x20;           ballx += dx;

&#x20;           bally += dy;

&#x20;           // 碰撞检测与处理

&#x20;           if (ballx == COLS - 1 || ballx < 0) {

&#x20;               dx = -dx;

&#x20;               beep();

&#x20;           }

&#x20;           if (bally < 0) {

&#x20;               dy = -dy;

&#x20;               beep();

&#x20;           }

&#x20;           // 碰撞挡板

&#x20;           if (bally == bary - 1 && ballx >= barx && ballx < barx + barlength) {

&#x20;               dy = -dy;

&#x20;               beep();

&#x20;           }

&#x20;           // 球落地：游戏结束

&#x20;           if (bally >= LINES - 1) {

&#x20;               game\_over = true;

&#x20;               mvaddstr(LINES/2, COLS/2 - 5, "Game Over!");

&#x20;               mvaddstr(LINES/2 + 1, COLS/2 - 10, "Press 'N' to restart");

&#x20;               refresh();

&#x20;           }

&#x20;       }

&#x20;       pthread\_mutex\_unlock(\&mutex);  // 解锁

&#x20;       usleep(delay \* 1000);  // 休眠（控制运动速度）

&#x20;   }

&#x20;   return NULL;

}

int main()

{

&#x20;   chtype input;

&#x20;   // 初始化curses

&#x20;   initscr();

&#x20;   cbreak();

&#x20;   noecho();

&#x20;   keypad(stdscr, TRUE);

&#x20;   curs\_set(0);

&#x20;   srand(time(NULL));  // 随机数种子（用于球的初始方向）

&#x20;   // 初始化互斥锁

&#x20;   pthread\_mutex\_init(\&mutex, NULL);

&#x20;   // 开始新游戏

&#x20;   new\_game();

&#x20;   // 创建绘图线程

&#x20;   pthread\_t tidp;

&#x20;   if (pthread\_create(\&tidp, NULL, paint\_thread, NULL) != 0) {

&#x20;       mvaddstr(0, 0, "Thread create error!");

&#x20;       refresh();

&#x20;       endwin();

&#x20;       return -1;

&#x20;   }

&#x20;   // 主线程：处理用户输入

&#x20;   while ((input = getch()) && input != ERR && input != 'q') {

&#x20;       pthread\_mutex\_lock(\&mutex);

&#x20;       switch (input) {

&#x20;           case KEY\_LEFT:  // 挡板左移

&#x20;               if (!game\_over)

&#x20;                   barx = MAX(barx - 1, 0);

&#x20;               break;

&#x20;           case KEY\_RIGHT:  // 挡板右移

&#x20;               if (!game\_over)

&#x20;                   barx = MIN(barx + 1, COLS - 1 - barlength);

&#x20;               break;

&#x20;           case 'n':  // 重新开始

&#x20;               new\_game();

&#x20;               break;

&#x20;       }

&#x20;       pthread\_mutex\_unlock(\&mutex);

&#x20;   }

&#x20;   // 清理资源

&#x20;   pthread\_cancel(tidp);  // 终止绘图线程

&#x20;   pthread\_join(tidp, NULL);  // 等待线程结束

&#x20;   pthread\_mutex\_destroy(\&mutex);  // 销毁互斥锁

&#x20;   endwin();

&#x20;   return 0;

}
```

编译命令（需链接 curses 和 pthread 库）：



```
gcc ball\_game\_thread.c -o ball\_game -lcurses -lpthread
```

> （注：文档部分内容可能由 AI 生成）